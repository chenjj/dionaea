Description: Add missing files
 dionaea-nisl (0.1.0.3-0.2) precise; urgency=low
 .
   * Add missing files
Author: Xiaoyu Liu (Vury Leo) <i@vuryleo.com>

---
The information above should follow the Patch Tagging Guidelines, please
checkout http://dep.debian.net/deps/dep3/ to learn about the format. Here
are templates for supplementary fields that you might want to add:

Origin: <vendor|upstream|other>, <url of original patch>
Bug: <url in upstream bugtracker>
Bug-Debian: http://bugs.debian.org/<bugnumber>
Bug-Ubuntu: https://launchpad.net/bugs/<bugnumber>
Forwarded: <no|not-needed|url proving that it has been forwarded>
Reviewed-By: <name and email of someone who approved the patch>
Last-Update: <YYYY-MM-DD>

--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -31,3 +31,6 @@
 dionaea_SOURCES += threads.c
 dionaea_SOURCES += bistream.c
 dionaea_SOURCES += processor.c
+dionaea_SOURCES += publish.c
+dionaea_SOURCES += hpfeeds.c
+dionaea_SOURCES += sha1.c
--- /dev/null
+++ b/src/hpfeeds.c
@@ -0,0 +1,196 @@
+/*
+  hpfeeds.c
+  Copyright (C) 2011 The Honeynet Project
+  Copyright (C) 2011 Tillmann Werner, tillmann.werner@gmx.de
+
+  This program is free software; you can redistribute it and/or modify
+  it under the terms of the GNU General Public License version 2 as 
+  published by the Free Software Foundation.
+
+  This program is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  GNU General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#include <arpa/inet.h>
+#include "hpfeeds.h"
+#include <stdlib.h>
+#include <string.h>
+
+#include "sha1.h"
+
+
+hpf_msg_t *hpf_msg_new(void) {
+	hpf_msg_t *msg;
+
+	msg = calloc(1, sizeof(hpf_msg_t));
+	msg->hdr.msglen = htonl(sizeof(msg->hdr));
+
+	return msg;
+}
+
+void hpf_msg_delete(hpf_msg_t *m) {
+	if (m) free(m);
+
+	return;
+}
+
+hpf_msg_t *hpf_msg_getmsg(u_char *data) {
+	return (hpf_msg_t *) data;
+}
+
+u_int32_t hpf_msg_getsize(hpf_msg_t *m) {
+	return ntohl(m->hdr.msglen);
+}
+
+u_int32_t hpf_msg_gettype(hpf_msg_t *m) {
+	return m->hdr.opcode;
+}
+
+hpf_msg_t *hpf_msg_add_chunk(hpf_msg_t **m, const u_char *data, size_t len) {
+	hpf_msg_t *msg = *m;
+	u_char l;
+
+	if (!m || !data || !len)
+		return NULL;
+
+	l = len < 0xff ? len : 0xff;
+
+	*m = msg = realloc(msg, ntohl(msg->hdr.msglen) + l + 1);
+
+	if (msg == NULL)
+		return NULL;
+
+	((u_char *) msg)[ntohl(msg->hdr.msglen)] = l;
+	memcpy(((u_char *) msg) + ntohl(msg->hdr.msglen) + 1, data, l);
+
+	msg->hdr.msglen = htonl(ntohl(msg->hdr.msglen) + 1 + l);
+
+	return msg;
+}
+
+hpf_chunk_t *hpf_msg_get_chunk(u_char *data, size_t len) {
+	hpf_chunk_t *c;
+
+	if (!data || !len) return NULL;
+
+	c = (hpf_chunk_t *) data;
+
+	// incomplete chunk?
+	if (c->len > len + 1) return NULL;
+
+	return c;
+}
+
+hpf_msg_t *hpf_msg_add_payload(hpf_msg_t **m, const u_char *data, size_t len) {
+	hpf_msg_t *msg = *m;
+
+	if (!m || !data || !len)
+		return NULL;
+
+	*m = msg = realloc(msg, ntohl(msg->hdr.msglen) + len);
+
+	if (msg == NULL)
+		return NULL;
+
+	memcpy(((u_char *) msg) + ntohl(msg->hdr.msglen), data, len);
+
+	msg->hdr.msglen = htonl(ntohl(msg->hdr.msglen) + len);
+
+	return msg;
+}
+
+hpf_msg_t *hpf_msg_error(u_char *err, size_t err_size) {
+	hpf_msg_t *msg;
+
+	msg = hpf_msg_new();
+
+	if (msg == NULL)
+		return NULL;
+
+	msg->hdr.opcode = OP_ERROR;
+
+	hpf_msg_add_payload(&msg, err, err_size);
+
+	return msg;
+}
+
+hpf_msg_t *hpf_msg_info(u_int32_t nonce, u_char *fbname, size_t fbname_len) {
+	hpf_msg_t *msg;
+
+	msg = hpf_msg_new();
+
+	if (msg == NULL)
+		return NULL;
+
+	msg->hdr.opcode = OP_INFO;
+
+	hpf_msg_add_chunk(&msg, fbname, fbname_len);
+
+	hpf_msg_add_payload(&msg, (u_char *) &nonce, sizeof(u_int32_t));
+
+	return msg;
+}
+
+hpf_msg_t *hpf_msg_auth(u_int32_t nonce, u_char *ident, size_t ident_len, u_char *secret, size_t secret_len) {
+	hpf_msg_t *msg;
+	SHA1Context ctx;
+	u_char hash[SHA1HashSize];
+
+	msg = hpf_msg_new();
+
+	if (msg == NULL)
+		return NULL;	
+
+	msg->hdr.opcode = OP_AUTH;
+
+	SHA1Reset(&ctx);
+	SHA1Input(&ctx, (u_int8_t *) &nonce, sizeof(nonce));
+	SHA1Input(&ctx, (u_int8_t *) secret, secret_len);
+	SHA1Result(&ctx, hash);
+
+	hpf_msg_add_chunk(&msg, ident, ident_len);
+
+	hpf_msg_add_payload(&msg, hash, SHA1HashSize);
+
+	return msg;
+}
+
+hpf_msg_t *hpf_msg_publish(u_char *ident, size_t ident_len, u_char *channel, size_t channel_len, u_char *data, size_t data_len) {
+	hpf_msg_t *msg;
+
+	msg = hpf_msg_new();
+
+	if (msg == NULL)
+		return NULL;
+
+	msg->hdr.opcode = OP_PUBLISH;
+
+	hpf_msg_add_chunk(&msg, ident, ident_len);
+	hpf_msg_add_chunk(&msg, channel, channel_len);
+
+	hpf_msg_add_payload(&msg, data, data_len);
+
+	return msg;
+}
+
+hpf_msg_t *hpf_msg_subscribe(u_char *ident, size_t ident_len, u_char *channel, size_t channel_len) {
+	hpf_msg_t *msg;
+
+	msg = hpf_msg_new();
+
+	if (msg == NULL)
+		return NULL;
+
+	msg->hdr.opcode = OP_SUBSCRIBE;
+
+	hpf_msg_add_chunk(&msg, ident, ident_len);
+
+	hpf_msg_add_payload(&msg, channel, channel_len);
+
+	return msg;
+}
--- /dev/null
+++ b/src/publish.c
@@ -0,0 +1,313 @@
+/*
+  hpclient.c
+  Copyright (C) 2011 The Honeynet Project
+  Copyright (C) 2011 Tillmann Werner, tillmann.werner@gmx.de
+
+  This program is free software; you can redistribute it and/or modify
+  it under the terms of the GNU General Public License version 2 as 
+  published by the Free Software Foundation.
+
+  This program is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  GNU General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#include "publish.h"
+#include <glib.h>
+
+session_state_t session_state;	// global session state
+char to_hex(char code) {
+  static char hex[] = "0123456789abcdef";
+  return hex[code & 15];
+}
+char *url_encode(char *str) {
+  char *pstr = str, *buf = malloc(strlen(str) * 3 + 1), *pbuf = buf;
+  while (*pstr) {
+    if (isalnum(*pstr) || *pstr == '-' || *pstr == '_' || *pstr == '.' || *pstr == '~') 
+      *pbuf++ = *pstr;
+    else if (*pstr == ' ') 
+      *pbuf++ = '+';
+    else 
+      *pbuf++ = '%', *pbuf++ = to_hex(*pstr >> 4), *pbuf++ = to_hex(*pstr & 15);
+    pstr++;
+  }
+  *pbuf = '\0';
+  return buf;
+}
+u_char *read_msg(int s) {
+	u_char *buffer;
+	u_int32_t msglen;
+
+	if (read(s, &msglen, 4) != 4) {
+		perror("read()");
+		return NULL;
+	}
+
+	if ((buffer = g_malloc0(ntohl(msglen))) == NULL) {
+		printf ("malloc() message buffer error");
+		return NULL;
+	}
+
+	*(u_int32_t *) buffer = msglen;
+	msglen = ntohl(msglen);
+
+	if (read(s, buffer + 4, msglen - 4) != (msglen - 4)) {
+		perror("read()");
+		return NULL;
+	}
+
+	return buffer;
+}
+void readConfig(char *conf_path,char *conf_name,char *config_buff)
+{
+    char config_linebuf[256];
+    char line_name[40];
+    char exchange_buf[256];
+    char *config_sign = "=";
+    char *leave_line;
+    FILE *f;
+    f = fopen(conf_path,"r");
+    if(f == NULL)
+    {
+        printf("OPEN CONFIG FALID\n");
+        return ;
+    }
+    fseek(f,0,SEEK_SET); 
+    while(fgets(config_linebuf,256,f) != NULL)
+    {   
+        if(strlen(config_linebuf) < 3) //判断是否是空行
+        {
+            continue;
+        }
+        if (config_linebuf[strlen(config_linebuf)-1] == 10) //去除最后一位是\n的情况
+        {
+            
+            memset(exchange_buf,0,sizeof(exchange_buf));
+            strncpy(exchange_buf,config_linebuf,strlen(config_linebuf)-1);
+            memset(config_linebuf,0,sizeof(config_linebuf));
+            strcpy(config_linebuf,exchange_buf);
+        }
+        memset(line_name,0,sizeof(line_name));
+        leave_line = strstr(config_linebuf,config_sign);
+        if(leave_line == NULL)                            //去除无"="的情况
+        {
+            continue;
+        }
+        int leave_num = leave_line - config_linebuf;
+        strncpy(line_name,config_linebuf,leave_num);
+        if(strcmp(line_name,conf_name) ==0)
+        {
+            strncpy(config_buff,config_linebuf+(leave_num+1),strlen(config_linebuf)-leave_num-1);
+            break;
+        }
+        if(fgetc(f)==EOF)
+        {
+            break;  
+        }
+        fseek(f,-1,SEEK_CUR);
+        memset(config_linebuf,0,sizeof(config_linebuf));
+    }
+    fclose(f);
+   
+}
+
+void* publish(void *buff) {
+	u_char *buf=(u_char *)malloc((strlen(buff)+2)*sizeof(u_char));
+	strcpy((char *)buf,(char *)buff);
+	//printf("\n%d %d %d\n",(int)strlen(buff),(int)strlen((char*)buf),(int)sizeof(buf));
+	printf("bistream : %s",(char *)buf);
+	cmd_t hpfdcmd;
+	hpf_msg_t *msg;
+	hpf_chunk_t *chunk;
+	u_char *data;
+	char *errmsg;
+	int s;
+	struct hostent *he;
+	
+	u_int32_t nonce = 0;
+
+	hpfdcmd=C_UNKNOWN;
+	msg = NULL;
+
+	hpfdcmd = C_PUBLISH;
+	char *cfgname="hpfeeds.cfg";
+	u_char channel[50] = "dionaea.bistream";
+	char hostname[50]="192.168.232.139";
+	u_char ident[50] ="ww3ee@hp1";
+	u_char secret[50] ="7w35rippuhx7704h";
+	char port[10];
+	readConfig(cfgname,"HOST",(char *)hostname);
+	readConfig(cfgname,"PORT",(char *)port);
+	readConfig(cfgname,"IDENT",(char *)ident);
+	readConfig(cfgname,"SECRET",(char *)secret);
+	readConfig(cfgname,"CHANNEL",(char *)channel);
+	
+	if ((he = gethostbyname(hostname)) == NULL) {
+		perror("gethostbyname()");
+		free(buf);
+		return NULL ; 
+	}
+
+	if (he->h_addrtype == AF_INET) {
+		struct sockaddr_in host;
+		bzero(&host, sizeof(host));
+		host.sin_family = AF_INET;
+		host.sin_addr = *(struct in_addr *) he->h_addr;
+		host.sin_port = htons(strtoul(port, 0, 0));
+		// connect to broker
+		if ((s = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) == -1) {
+			perror("socket()");
+			free(buf);
+			return NULL ;
+		}
+		fprintf(stderr, "connecting to %s:%u\n", inet_ntoa(host.sin_addr), ntohs(host.sin_port));
+		if (connect(s, (struct sockaddr *) &host, sizeof(host)) == -1) {
+			printf("connect to server error");
+			free(buf);
+			return NULL;
+		}
+	}
+	else if (he->h_addrtype == AF_INET6) {
+		struct sockaddr_in6 host;
+		bzero(&host, sizeof(host));
+		host.sin6_family = AF_INET6;
+		if ( inet_pton(AF_INET6, he->h_addr, &host.sin6_addr) < 0 ) {
+			perror("inet_pton()");
+			free(buf);
+			return NULL;     
+		 }
+		host.sin6_port = htons(strtoul(port, 0, 0));
+		// connect to broker
+		if ((s = socket(AF_INET6, SOCK_STREAM, IPPROTO_TCP)) == -1) {
+			perror("socket()");
+			free(buf);
+			return NULL;
+		}
+		//fprintf(stderr, "connecting to %s:%u\n", inet_ntoa(host.sin6_addr), ntohs(host.sin6_port));
+		if (connect(s, (struct sockaddr *) &host, sizeof(host)) == -1) {
+			printf("connect to server error");
+			free(buf);
+			return NULL;
+		}
+	}
+	else{
+		fprintf(stderr, "Unsupported address type\n");
+		free(buf);
+		return NULL;
+	}
+
+
+
+
+	session_state = S_INIT; // initial session state
+
+	// this is our little session state machine
+	for (;;) switch (session_state) {
+	case S_INIT:
+		// read info message
+		if ((data = read_msg(s)) == NULL) break;
+		msg = (hpf_msg_t *) data;
+			
+		switch (msg->hdr.opcode) {
+		case OP_INFO:
+
+			chunk = hpf_msg_get_chunk(data + sizeof(msg->hdr), ntohl(msg->hdr.msglen) - sizeof(msg->hdr));
+			if (chunk == NULL) {
+				fprintf(stderr, "invalid message format\n");
+				free(buf);
+				return NULL;
+			}
+
+			nonce = *(u_int32_t *) (data + sizeof(msg->hdr) + chunk->len + 1);
+
+			session_state = S_AUTH;
+
+			free(data);
+
+			break;
+		case OP_ERROR:
+			session_state = S_ERROR;
+			break;
+		default:
+			fprintf(stderr, "unknown server message (type %u)\n", msg->hdr.opcode);
+			free(buf);
+			return NULL;
+		}
+
+		break;
+	case S_AUTH:
+		// send auth message
+		fprintf(stderr, "sending authentication...\n");
+		msg = hpf_msg_auth(nonce, (u_char *) ident, strlen((const char *)ident), (u_char *) secret, strlen((const char *)secret));
+
+		if (write(s, (u_char *) msg, ntohl(msg->hdr.msglen)) == -1) {
+			perror("write()");
+			free(buf);
+			return NULL;
+		}
+		hpf_msg_delete(msg);
+	
+		if (hpfdcmd == C_SUBSCRIBE)
+			session_state = S_SUBSCRIBE;
+		else 
+			session_state = S_PUBLISH;
+		break;
+	case S_PUBLISH:
+		// send publish message
+		fprintf(stderr, "publish bistream  ...\n");
+		int len=strlen((const char *)buf);
+		//printf("%s",buf);
+		msg = hpf_msg_publish((u_char *) ident, strlen((const char *)ident), (u_char *) channel, strlen((const char *)channel),(u_char *)buf,len);
+		if (write(s, (u_char *) msg, ntohl(msg->hdr.msglen)) == -1) {
+			perror("write()");
+			free(buf);
+			return NULL;
+		}
+		hpf_msg_delete(msg);
+		free(buf);
+		return NULL;
+		break;
+	case S_ERROR:
+		if (msg) {
+			// msg is still valid
+			if ((errmsg = calloc(1, msg->hdr.msglen - sizeof(msg->hdr))) == NULL) {
+				perror("calloc()");
+				free(buf);
+				return NULL;
+			}
+			memcpy(errmsg, msg->data, msg->hdr.msglen - sizeof(msg->hdr));
+
+			fprintf(stderr, "server error: '%s'\n", errmsg);
+			free(errmsg);
+			free(msg);
+		}
+
+		session_state = S_TERMINATE;
+		break;
+	case S_TERMINATE:
+		fprintf(stderr, "terminated.\n");
+		close(s);
+		free(buf);
+		return NULL;
+	default:
+		fprintf(stderr, "unknown session state\n");
+		close(s);
+		free(buf);
+		return NULL;
+	}
+
+	close(s);
+	free(buf);	
+	return NULL;
+}
+
+/*
+int main(int argc, char *argv[])
+{
+	u_char data[20]="char data";
+	publish(data);
+}*/
--- /dev/null
+++ b/src/sha1.c
@@ -0,0 +1,390 @@
+/*
+ *  sha1.c
+ *
+ *  Description:
+ *      This file implements the Secure Hashing Algorithm 1 as
+ *      defined in FIPS PUB 180-1 published April 17, 1995.
+ *
+ *      The SHA-1, produces a 160-bit message digest for a given
+ *      data stream.  It should take about 2**n steps to find a
+ *      message with the same digest as a given message and
+ *      2**(n/2) to find any two messages with the same digest,
+ *      when n is the digest size in bits.  Therefore, this
+ *      algorithm can serve as a means of providing a
+ *      "fingerprint" for a message.
+ *
+ *  Portability Issues:
+ *      SHA-1 is defined in terms of 32-bit "words".  This code
+ *      uses <stdint.h> (included via "sha1.h" to define 32 and 8
+ *      bit unsigned integer types.  If your C compiler does not
+ *      support 32 bit unsigned integers, this code is not
+ *      appropriate.
+ *
+ *  Caveats:
+ *      SHA-1 is designed to work with messages less than 2^64 bits
+ *      long.  Although SHA-1 allows a message digest to be generated
+ *      for messages of any number of bits less than 2^64, this
+ *      implementation only works with messages with a length that is
+ *      a multiple of the size of an 8-bit character.
+ *
+ */
+
+#include "sha1.h"
+
+/*
+ *  Define the SHA1 circular left shift macro
+ */
+#define SHA1CircularShift(bits,word) \
+                (((word) << (bits)) | ((word) >> (32-(bits))))
+
+/* Local Function Prototyptes */
+void SHA1PadMessage(SHA1Context *);
+void SHA1ProcessMessageBlock(SHA1Context *);
+
+/*
+ *  SHA1Reset
+ *
+ *  Description:
+ *      This function will initialize the SHA1Context in preparation
+ *      for computing a new SHA1 message digest.
+ *
+ *  Parameters:
+ *      context: [in/out]
+ *          The context to reset.
+ *
+ *  Returns:
+ *      sha Error Code.
+ *
+ */
+int SHA1Reset(SHA1Context *context)
+{
+    if (!context)
+    {
+        return shaNull;
+    }
+
+    context->Length_Low             = 0;
+    context->Length_High            = 0;
+    context->Message_Block_Index    = 0;
+
+    context->Intermediate_Hash[0]   = 0x67452301;
+    context->Intermediate_Hash[1]   = 0xEFCDAB89;
+    context->Intermediate_Hash[2]   = 0x98BADCFE;
+    context->Intermediate_Hash[3]   = 0x10325476;
+    context->Intermediate_Hash[4]   = 0xC3D2E1F0;
+
+    context->Computed   = 0;
+    context->Corrupted  = 0;
+
+    return shaSuccess;
+}
+
+/*
+ *  SHA1Result
+ *
+ *  Description:
+ *      This function will return the 160-bit message digest into the
+ *      Message_Digest array  provided by the caller.
+ *      NOTE: The first octet of hash is stored in the 0th element,
+ *            the last octet of hash in the 19th element.
+ *
+ *  Parameters:
+ *      context: [in/out]
+ *          The context to use to calculate the SHA-1 hash.
+ *      Message_Digest: [out]
+ *          Where the digest is returned.
+ *
+ *  Returns:
+ *      sha Error Code.
+ *
+ */
+int SHA1Result( SHA1Context *context,
+                uint8_t Message_Digest[SHA1HashSize])
+{
+    int i;
+
+    if (!context || !Message_Digest)
+    {
+        return shaNull;
+    }
+
+    if (context->Corrupted)
+    {
+        return context->Corrupted;
+    }
+
+    if (!context->Computed)
+    {
+        SHA1PadMessage(context);
+        for(i=0; i<64; ++i)
+        {
+            /* message may be sensitive, clear it out */
+            context->Message_Block[i] = 0;
+        }
+        context->Length_Low = 0;    /* and clear length */
+        context->Length_High = 0;
+        context->Computed = 1;
+
+    }
+
+    for(i = 0; i < SHA1HashSize; ++i)
+    {
+        Message_Digest[i] = context->Intermediate_Hash[i>>2]
+                            >> 8 * ( 3 - ( i & 0x03 ) );
+    }
+
+    return shaSuccess;
+}
+
+/*
+ *  SHA1Input
+ *
+ *  Description:
+ *      This function accepts an array of octets as the next portion
+ *      of the message.
+ *
+ *  Parameters:
+ *      context: [in/out]
+ *          The SHA context to update
+ *      message_array: [in]
+ *          An array of characters representing the next portion of
+ *          the message.
+ *      length: [in]
+ *          The length of the message in message_array
+ *
+ *  Returns:
+ *      sha Error Code.
+ *
+ */
+int SHA1Input(    SHA1Context    *context,
+                  const uint8_t  *message_array,
+                  unsigned       length)
+{
+    if (!length)
+    {
+        return shaSuccess;
+    }
+
+    if (!context || !message_array)
+    {
+        return shaNull;
+    }
+
+    if (context->Computed)
+    {
+        context->Corrupted = shaStateError;
+
+        return shaStateError;
+    }
+
+    if (context->Corrupted)
+    {
+         return context->Corrupted;
+    }
+    while(length-- && !context->Corrupted)
+    {
+    context->Message_Block[context->Message_Block_Index++] =
+                    (*message_array & 0xFF);
+
+    context->Length_Low += 8;
+    if (context->Length_Low == 0)
+    {
+        context->Length_High++;
+        if (context->Length_High == 0)
+        {
+            /* Message is too long */
+            context->Corrupted = 1;
+        }
+    }
+
+    if (context->Message_Block_Index == 64)
+    {
+        SHA1ProcessMessageBlock(context);
+    }
+
+    message_array++;
+    }
+
+    return shaSuccess;
+}
+
+/*
+ *  SHA1ProcessMessageBlock
+ *
+ *  Description:
+ *      This function will process the next 512 bits of the message
+ *      stored in the Message_Block array.
+ *
+ *  Parameters:
+ *      None.
+ *
+ *  Returns:
+ *      Nothing.
+ *
+ *  Comments:
+
+ *      Many of the variable names in this code, especially the
+ *      single character names, were used because those were the
+ *      names used in the publication.
+ *
+ *
+ */
+void SHA1ProcessMessageBlock(SHA1Context *context)
+{
+    const uint32_t K[] =    {       /* Constants defined in SHA-1   */
+                            0x5A827999,
+                            0x6ED9EBA1,
+                            0x8F1BBCDC,
+                            0xCA62C1D6
+                            };
+    int           t;                 /* Loop counter                */
+    uint32_t      temp;              /* Temporary word value        */
+    uint32_t      W[80];             /* Word sequence               */
+    uint32_t      A, B, C, D, E;     /* Word buffers                */
+
+    /*
+     *  Initialize the first 16 words in the array W
+     */
+    for(t = 0; t < 16; t++)
+    {
+        W[t] = context->Message_Block[t * 4] << 24;
+        W[t] |= context->Message_Block[t * 4 + 1] << 16;
+        W[t] |= context->Message_Block[t * 4 + 2] << 8;
+        W[t] |= context->Message_Block[t * 4 + 3];
+    }
+
+    for(t = 16; t < 80; t++)
+    {
+       W[t] = SHA1CircularShift(1,W[t-3] ^ W[t-8] ^ W[t-14] ^ W[t-16]);
+    }
+
+    A = context->Intermediate_Hash[0];
+    B = context->Intermediate_Hash[1];
+    C = context->Intermediate_Hash[2];
+    D = context->Intermediate_Hash[3];
+    E = context->Intermediate_Hash[4];
+
+    for(t = 0; t < 20; t++)
+    {
+        temp =  SHA1CircularShift(5,A) +
+                ((B & C) | ((~B) & D)) + E + W[t] + K[0];
+        E = D;
+        D = C;
+        C = SHA1CircularShift(30,B);
+
+        B = A;
+        A = temp;
+    }
+
+    for(t = 20; t < 40; t++)
+    {
+        temp = SHA1CircularShift(5,A) + (B ^ C ^ D) + E + W[t] + K[1];
+        E = D;
+        D = C;
+        C = SHA1CircularShift(30,B);
+        B = A;
+        A = temp;
+    }
+
+    for(t = 40; t < 60; t++)
+    {
+        temp = SHA1CircularShift(5,A) +
+               ((B & C) | (B & D) | (C & D)) + E + W[t] + K[2];
+        E = D;
+        D = C;
+        C = SHA1CircularShift(30,B);
+        B = A;
+        A = temp;
+    }
+
+    for(t = 60; t < 80; t++)
+    {
+        temp = SHA1CircularShift(5,A) + (B ^ C ^ D) + E + W[t] + K[3];
+        E = D;
+        D = C;
+        C = SHA1CircularShift(30,B);
+        B = A;
+        A = temp;
+    }
+
+    context->Intermediate_Hash[0] += A;
+    context->Intermediate_Hash[1] += B;
+    context->Intermediate_Hash[2] += C;
+    context->Intermediate_Hash[3] += D;
+    context->Intermediate_Hash[4] += E;
+
+    context->Message_Block_Index = 0;
+}
+
+/*
+ *  SHA1PadMessage
+ *
+
+ *  Description:
+ *      According to the standard, the message must be padded to an even
+ *      512 bits.  The first padding bit must be a '1'.  The last 64
+ *      bits represent the length of the original message.  All bits in
+ *      between should be 0.  This function will pad the message
+ *      according to those rules by filling the Message_Block array
+ *      accordingly.  It will also call the ProcessMessageBlock function
+ *      provided appropriately.  When it returns, it can be assumed that
+ *      the message digest has been computed.
+ *
+ *  Parameters:
+ *      context: [in/out]
+ *          The context to pad
+ *      ProcessMessageBlock: [in]
+ *          The appropriate SHA*ProcessMessageBlock function
+ *  Returns:
+ *      Nothing.
+ *
+ */
+
+void SHA1PadMessage(SHA1Context *context)
+{
+    /*
+     *  Check to see if the current message block is too small to hold
+     *  the initial padding bits and length.  If so, we will pad the
+     *  block, process it, and then continue padding into a second
+     *  block.
+     */
+    if (context->Message_Block_Index > 55)
+    {
+        context->Message_Block[context->Message_Block_Index++] = 0x80;
+        while(context->Message_Block_Index < 64)
+        {
+            context->Message_Block[context->Message_Block_Index++] = 0;
+        }
+
+        SHA1ProcessMessageBlock(context);
+
+        while(context->Message_Block_Index < 56)
+        {
+            context->Message_Block[context->Message_Block_Index++] = 0;
+        }
+    }
+    else
+    {
+        context->Message_Block[context->Message_Block_Index++] = 0x80;
+        while(context->Message_Block_Index < 56)
+        {
+
+            context->Message_Block[context->Message_Block_Index++] = 0;
+        }
+    }
+
+    /*
+     *  Store the message length as the last 8 octets
+     */
+    context->Message_Block[56] = context->Length_High >> 24;
+    context->Message_Block[57] = context->Length_High >> 16;
+    context->Message_Block[58] = context->Length_High >> 8;
+    context->Message_Block[59] = context->Length_High;
+    context->Message_Block[60] = context->Length_Low >> 24;
+    context->Message_Block[61] = context->Length_Low >> 16;
+    context->Message_Block[62] = context->Length_Low >> 8;
+    context->Message_Block[63] = context->Length_Low;
+
+    SHA1ProcessMessageBlock(context);
+}
+
